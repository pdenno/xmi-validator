
;;; Purposes:  - Write Canonical-form XMI 2.1 for a model.
;;;            - Transform uploaded XMI to canonical. 

;;; NOTE: This stuff sometimes uses with-vo, but sometimes looks like it won't!
;;; 2012-05-25: As of today, the above is no longer true. 

(in-package :mofi)

(shadowing-import '(pod:dbg-msg)) ; 2012-05-25 mystery

;;;==========================================================
;;; Direct Canonical generation from file.
;;;==========================================================
(defun xmi-direct-transform (mut &key debug-file)
  "Transform the xqdm document (user-doc) into canonical XMI; Write it as tmp:user-canonical.xml."
  (let ((doc (user-doc (processing-results mut))))
    (dbg-msg :validate 5 "~%Start")
    (setf (mut *spare-session-vo*) mut)
    (xmi-compute-canonical-xmiid mut)
    (dbg-msg :validate 5 "~%Qualified names")
    (xmi-remove-extensions doc)
    (dbg-msg :validate 5 "~%Remove extensions")
    (xmi-ensure-xmi-root doc)    
    (dbg-msg :validate 5 "~%Ensure root")
;   (xmi-remove-null-string-attrs doc) ; I should NOT be doing this (except for valid.xmi).
    (xmi-elementize doc mut)
    (dbg-msg :validate 5 "~%Elementize")
    (xmi-remove-mixed-content doc)
    (dbg-msg :validate 5 "~%Remove mixed content")
    (xmi-if-href-remove-type doc)
    (dbg-msg :validate 5 "~%If href remove type")
    (xmi-xmiid-xmiuuid-prune-and-place doc mut)
    (dbg-msg :validate 5 "~%Prune and place xmiid/uuid")
    (xmi-reset-xmiid doc mut)
    (dbg-msg :validate 5 "~%Reset xmiid")
    (xmi-reset-hrefs doc mut)
    (dbg-msg :validate 5 "~%Reset hrefs")
    (xmi-set-stereo-base-obj (processing-results mut))
    (dbg-msg :validate 5 "~%Set stereo base objs")
    (xmi-reorder doc mut)
    (dbg-msg :validate 5 "~%XMI reorder")
    (xmi-set-object-references doc mut)
    (dbg-msg :validate 5 "~%Set object refs")
    (xmi-fix-namespace-uri doc)  
    (dbg-msg :validate 5 "~%Set fix namespace uri")
    (xmi-reset-xqdm-ordinality doc)
    ;; Write it
    (let ((*print-pretty* nil))
      (with-slots (xmi-namespace) (processing-results mut)
	(let ((xmlp::*default-namespaces*
	       (append (list (cons "xmi" xmi-namespace)) xmlp::*default-namespaces*)))
	  (xmlp:write-node doc (phttp::user-pathname (pod:lpath :tmp "diff/canonical-pre-reflow.xml")))))
      #+linux
      (usr-bin-xmllint :infile  (phttp::user-pathname (pod:lpath :tmp "diff/canonical-pre-reflow.xml"))
		       :outfile (or debug-file
				    (phttp::user-pathname (pod:lpath :tmp "diff/user-canonical.xml"))))
      #+mswindows
      (pod::copy-file (phttp::user-pathname (pod:lpath :tmp "diff/canonical-pre-reflow.xml"))
		      (or debug-file (phttp::user-pathname (pod:lpath :tmp "diff/user-canonical.xml"))))
      (dbg-msg :validate 5 "~%XMLLINT")
      doc)))

(defun xmi-ensure-xmi-root (doc)
  "Ensure that the root is an XML document. If it has attributes (like version) eliminate them.
   Put the namespace definitions in it."
  (if (xml-typep (xqdm:root doc) (xmi-sym "XMI"))
      (setf (xqdm:attributes (xqdm:root doc)) nil) 
      (let* ((whatever (xqdm:root doc))
	     (comment  (make-instance 'xqdm:comment-node 
				      :children (list (format nil " Generated by the NIST Validator on ~A." (now)))))
	     (new-root (xml-make-node doc nil (xmi-sym "XMI")
				      (list comment whatever) :type 'xqdm:elem-node)))
	(setf (xqdm:namespaces new-root) (xqdm:namespaces whatever))
	(setf (xqdm:namespaces whatever) nil)
	(setf (xqdm:attributes whatever)
	      (remove-if 
	       #'(lambda (x) 
		   (or (eql (xqdm:name x) (xmi-sym "version"))
		       #|pod18 (eql (xqdm:name x) '|http://www.w3.org/2001/XMLSchema-instance|::|schemaLocation|)|#))
	       (xqdm:attributes whatever)))
	(setf (xqdm:children doc) (list new-root))
	(setf (xqdm:root doc) new-root)))
    doc)

;;; Note that before here (xqdm:value ns-obj) was set to the model name ("UML211" etc.)
;;; which is also the package name. We want the second nickname (see essential-load.lisp).
(defun xmi-fix-namespace-uri (doc)
  "Set XML namespace tags to the preferred ones."
  (loop for ns in (xqdm:namespaces (xqdm:root doc)) do
       (when-bind (model (find-model (xqdm:value ns) :error-p nil))
	 (when-bind (nick (second (nicknames model)))
	   (setf (slot-value ns 'xqdm::value) nick)  ; not necessary?
	   (setf (xqdm:children ns) (list nick)))))) ; necessary!

(defun xmi-remove-extensions (doc)
  "Remove xmi:Extension objects."
    (let ((rems (mapcar #'xmi-sym '("extension" "Extension" "documentation" "Documentation"
				    "label" "Label" "version" "Version"))))
      (depth-first-search 
       doc
       #'fail 
       #'xqdm:children 
       :do #'(lambda (node) 
	       (when (xqdm:element-p node)
		 (setf (xqdm:children node)
		       (remove-if #'(lambda (x) (member (xqdm:name x) rems))
				  (xqdm:children node))))))))

;;; This is only used to clean up valid.xmi -- don't fix the user's XMI!
#+nil
(defun xmi-remove-null-string-attrs (doc)
  "If the element has an attr whose value is a null string, throw it away."
  (depth-first-search 
   doc
   #'fail 
   #'xqdm:children 
   :do #'(lambda (node) 
	   (when (xqdm:element-p node)
	     (setf (xqdm:attributes node)
		   (remove-if #'(lambda (x) (null (xqdm:children x)))
			      (xqdm:attributes node)))))))

(defun xmi-elementize (doc mut)
  "Make every attribute but xmi:id, xmi:idref, xmi:uuid and xmi:type an element.
   Place the remaining attributes in that order."
  (with-slots (xmiid2obj-ht xqdm2model-ht) (processing-results mut)
    (let* ((keep-syms (mapcar #'xmi-sym '("id" "idref" "uuid" "type")))
	   (keep-attrs (cons (intern "href" "") keep-syms))
	   (xmi-idref (xmi-sym "idref")))
      (depth-first-search 
       (xqdm:root doc)
       #'fail 
       #'xqdm:children 
       :do #'(lambda (node) 
	       (when (xqdm:element-p node)
		 (loop for attr in (xqdm:attributes node)
		       for name = (xqdm:name attr) do
		      (unless (member name keep-attrs :test #'equal)
			(setf (xqdm:attributes node) (remove attr (xqdm:attributes node)))
			(let (refs?) ; Check whether XML attr is xmi:idref (one or more).
			  (if (when-bind (slot/stereo (gethash attr xqdm2model-ht))
				(and 
				 (or (and (typep slot/stereo 'slot-definition) 
					  (not (primitive-type-p (slot-definition-range slot/stereo))))
				     (stereotype-p slot/stereo))
				 (setf refs? (split (car (xqdm:children attr)) #\Space))
				 (gethash (car refs?) xmiid2obj-ht)))
			      (loop for ref in refs?
				    for new-elem = (add-elem (xqdm:local-part name) node doc) do
				    (add-attr xmi-idref ref new-elem) 
				    (if-bind (obj (gethash ref xmiid2obj-ht))
					    (setf (gethash new-elem xqdm2model-ht) obj)
					    (format *error-output* "~%No attr to associate with ~A" ref)))
			      (let ((new-elem (add-elem (xqdm:local-part name) node doc)))
				(set-content new-elem (car (xqdm:children attr)))
				(when-bind (attr-obj (gethash attr xqdm2model-ht)) ; 2012-09-07 if-bind now when-bind
				  (setf (gethash new-elem xqdm2model-ht) attr-obj)))))))))))))
;				  ;; Still not sure what this is about. Related to stereotype apps.
;				  (format *error-output* 
;					  "~%No XML attr for new-elem: new-elem = ~A attr = ~A"
;					  new-elem attr)))))))))))))


(defun xmi-set-object-references (doc mut)
  "Walk through every xqdm:element-p (this after elementizing), replace xmi:idref 
   names with the value of the sort-name slot."
  (with-slots (xmiid2obj-ht) (processing-results mut)
    (let ((xmi-idref (xmi-sym "idref")))
      (depth-first-search 
       doc
       #'fail 
       #'xqdm:children 
       :do 
       #'(lambda (node)
	   (when (xqdm:element-p node)
	     (when-bind (idref (find xmi-idref (xqdm:attributes node) :key #'xqdm:name))
	       (when-bind (obj (gethash (xqdm:value idref) xmiid2obj-ht))
		 (when (typep obj 'mm-root-supertype)
		   (when-bind (val (%sort-name obj))
		     (setf (xqdm:value idref) val)))))))))))

(defun xmi-remove-mixed-content (doc)
  "When children are strings and elements, remove the strings."
  (depth-first-search 
   doc
   #'fail 
   #'xqdm:children 
   :do #'(lambda (node) 
	   (when (and (find-if #'stringp  (xqdm:children node))
		      (find-if #'xqdm:element-p (xqdm:children node)))
	     (setf (xqdm:children node)
		   (remove-if #'stringp (xqdm:children node)))))))

(defun xmi-if-href-remove-type (doc)
  "If the element has an href attr, throw away its type attr."
  (let ((xmi-type (xmi-sym "type"))
	(href (intern "href" "")))
    (depth-first-search 
     doc
     #'fail 
     #'xqdm:children 
     :do #'(lambda (node) 
	     (when (xqdm:element-p node)
	       (when (member href (xqdm:attributes node) :key #'xqdm:name)
		 (setf (xqdm:attributes node)
		       (remove-if #'(lambda (x) (eql xmi-type (xqdm:name x)))
				  (xqdm:attributes node)))))))))

(defun xmi-reset-xmiid (doc mut)
  "Set the XMI-ID to the value in sort-name (if exists), which was calculated using the
   procedure described in Clause B.6 of the Canonical XMI Spec. If no sort-name, (e.g. a tag)
   calculate a name."
  (with-slots (xmiid2obj-ht) (processing-results mut)
    (let ((xmi-id (xmi-sym "id")))
      (depth-first-search 
       doc
       #'fail 
       #'xqdm:children 
       :do #'(lambda (node) 
	       (when (xqdm:element-p node)
		 (mvb (old-id attr) (xml-get-attr-value node xmi-id)
		   (when attr ; POD problem if no old-id...may want to gensym while reading
		     (if-bind (obj (gethash old-id xmiid2obj-ht))
			      (let (canon-id) ; 2012 - others are cmof:Tag. 2012-09-07 of no %sort-name alt compute.
				(if (and (typep obj 'mm-root-supertype) (%sort-name obj))
				    (setf canon-id (%sort-name obj))
				    (setf canon-id (xmi-compute-canonical-xmiid-alternative/tags mut doc old-id)))
				(setf (xqdm:children attr) (list canon-id))
				(setf (xqdm:value attr) canon-id))
			      (warn "old xmi:id ~A not in xmiid2obj-ht" old-id))))))))))


(defun xmi-xmiid-xmiuuid-prune-and-place (doc mut)
  "Rule 7 from canonical RFC: xmi:id and xmi:uuid are always present except
   they are not present for values that are datatypes, enumerations and primitives.
   This removes xmi:id and xmi:uuid from those types and adds an xmi:uuid to 
   all other objects (not datatypes, enums or primitives) that don't have one. "
  (with-slots (xmiid2obj-ht) (processing-results mut)
    (let ((xmi-id (xmi-sym "id"))
	  (xmi-uuid (xmi-sym "uuid")))
      (depth-first-search 
       doc
       #'fail 
       #'xqdm:children 
       :do #'(lambda (node) 
	       (when (xqdm:element-p node)
		 (when-bind (old-id (xml-get-attr-value node xmi-id))
		   (when-bind (obj (gethash old-id xmiid2obj-ht))
		     (if (or (datatype-p obj) (primitive-type-p obj) (enum-p obj))
			 (progn
			   (mvb (val attr) (xml-get-attr-value node xmi-id)
			     (declare (ignore val))
			     (when attr (setf (xqdm:children node) (remove attr (xqdm:children node)))))
			   (mvb (val attr) (xml-get-attr-value node xmi-uuid)
			     (declare (ignore val))
			     (when attr (setf (xqdm:children node) (remove attr (xqdm:children node))))))
			 (progn
			   (mvb (val attr) (xml-get-attr-value node xmi-uuid)
			     (declare (ignore val))
			     (unless attr (add-attr xmi-uuid (new-uuid) node)))))))))))))


;;; If the thing isn't found as a model, should this lookup in xmiid2obj-ht???
;;; POD Assuming _0 is dangerous. The xmi:id of the object should be used.
(defun xmi-reset-hrefs (doc mut)
  "References to profiles and other files should use the href#_0."
  (let ((profile-type (intern "Profile" (lisp-package (model-n+1 mut)))))
    (depth-first-search 
     doc
     #'fail 
     #'xqdm:children 
     :do #'(lambda (node) 
	     (when (xqdm:element-p node)
	       (when (xml-typep node "href") ; at this point in processing, it is a node, not attr.
		 (when-bind (obj (lookup-href (car (xqdm:children node))))
		   (when (typep obj profile-type)
		     (when-bind (name (%token-position obj)) ; stores an href URL. (2012 was source-elem)
		       (mvb (success vec) (cl-ppcre:scan-to-strings "(.+)#(.+)" name)
			 (when success
			   (unless (string= (aref vec 1) "_0")
			     (setf (xqdm:children node) 
				   (list (format nil "~A#_0" (aref vec 0))))))))))))))))


(defun xmi-set-stereo-base-obj (presults)
  "For each xml:element representing a stereotype application, change the
   base object to an xmi:idref attribute, rather than element content."
  (with-slots (stereo2base-ht xmiid2obj-ht) presults
    (let ((xmi-idref (xmi-sym "idref")))
      (loop for stereo-obj being the hash-key of stereo2base-ht 
	 for source-elem = (%source-elem stereo-obj) do
	   (when-bind (base-elem (car (xml-collect-elem 
				       #'(lambda (x) (cl-ppcre:scan "^base_" (xqdm:local-part (xqdm:name x))))
				       source-elem)))
	     (when-bind (old-xmiid (car (xqdm:children base-elem)))
	       (setf (xqdm:children base-elem) nil)
	       (when-bind (obj (gethash old-xmiid xmiid2obj-ht))
		 (add-attr xmi-idref (%sort-name obj) base-elem))))))))

#|
B5.1 ORDERING OF ELEMENTS

The order of the top level elements in the XMI file (direct descendants of the XMI element) is 
alphabetic by XML element name (based on the metamodel classifier) and then alphabetic by xmi:uuid.

B5.2 PROPERTY ELEMENTS

The order of the XML elements of Properties is the order of the properties of the class in the metamodel. 
This is determined by navigating the class hierarchy ‘depth first’ (e.g. highest superclass first).  
In the case of multiple inheritance this is determined by alphabetic order of superclasses and 
ignoring properties already present.

B5.3 PROPERTY CONTENT FOR CLASS-TYPED PROPERTIES

For ordering of elements within the serialization of a class-typed property value (usually an association end), 
where the property does not have isOrdered=’true’ in the metamodel, the ordering is as follows:

  *	All nested elements precede all link elements (those referencing another element)
        Within the set of nested elements the order is alphabetic by uuid.

  *	Within the set of link elements all links using xmi:idref preceded elements using href.

The set of xmi:idref elements is alphabetically ordered by the value of the xmi:idref, 
and the set of href elements is alphabetically ordered by the value of the href. 

B5.4 PROPERTY CONTENT FOR DATATYPE-TYPED PROPERTIES

For ordering of elements within the serialization of a data-typed property value, where the property 
does not have isOrdered=’true’ in the metamodel, there will be no links nor xmi:uuids and the ordering 
is as follows. 

Note that for structured Datatypes the properties will be ordered as per B5.1.

    *	For structured datatypes the nested elements are alphabetically ordered by the values of their properties, 
        taken in order (if the values of the first properties are identical the second is compared and so on)
    *	For simple datatypes the nested elements are sorted alphabetically by their values.
        Note that alphabetic ordering is used – so that, even if the property is of type Integer, 
        “10” will precede “9”.
|#
			 
(defun xmi-reorder (doc mut)
  "Sort XML toplevel and OCL unordered collections into sort-name order."
  (xmi-reorder-toplevel doc)
  (xmi-reorder-model mut)
  (xmi-reorder-stereos mut)
  (xmi-reorder-attrs doc))

(defun xmi-reorder-toplevel (doc)
  "Reorder toplevel elements.
   The order of the top level elements in the XMI file (direct descendants of the XMI element) is 
   alphabetic by XML element name (based on the metamodel classifier) and then alphabetic by xmi:uuid."
  (let* ((xmi-uuid (xmi-sym "uuid"))
	 (all-children (xqdm:children (xqdm:root doc)))
	 (doc-node (xml-find-child "Documentation" all-children))
	 (sorted-children 
	  (sort
	   (remove doc-node all-children)
	   #'(lambda (x y)
	       (let ((name-x (xqdm:name x))
		     (name-y (xqdm:name y)))
		 (cond ((string<  name-x name-y) t)
		       ((string<  name-y name-x) nil)
		       (t (string< (xml-get-attr-value x xmi-uuid)
				   (xml-get-attr-value y xmi-uuid)))))))))
    (setf (xqdm:children (xqdm:root doc))
	  (if doc-node (cons doc-node sorted-children) sorted-children))))

(defun xmi-reorder-model (mut)
  "Reorder every XML object, starting at Model or Profile."
  (when-bind (model-obj 
	      (find-if #'(lambda (x) 
			   (let ((type-name (string (class-name (class-of x)))))
			     (or (string= type-name "Model")
				 (string= type-name "Profile"))))
		       (coerce (members mut) 'list)))
;    (with-slots (xmiid2obj-ht) (processing-results mut)
      (depth-first-search (%source-elem model-obj) 
			  #'fail 
			  #'xqdm:children 
			  :do #'(lambda (n)
				  (xmi-reorder-node n mut)))));)

(defun xmi-reorder-stereos (mut)
  (loop for elem across (stereo-elems (processing-results mut))
     do (xmi-reorder-node elem mut)))

(defun xmi-reorder-attrs (doc)
  "Make every attribute but xmi:id, xmi:idref, xmi:uuid and xmi:type an element.
   Place the remaining attributes in that order."
  (let ((keep-attrs (cons (intern "href" "") 
			  (mapcar #'xmi-sym '("id" "idref" "uuid" "type")))))
    (depth-first-search 
     (xqdm:root doc)
     #'fail 
     #'xqdm:children 
     :do #'(lambda (node) 
	     (when (xqdm:element-p node)
	       ;; Reorder remaining attributes (xmi::id xmi::uuid xmi::type)
	       (setf (xqdm:attributes node) 
		     (sort 
		      (xqdm:attributes node) 
		      #'(lambda (x y)
			  (> (length (member (xqdm:name x) keep-attrs))
			     (length (member (xqdm:name y) keep-attrs)))))))))))

(declaim (inline unordered-slot-test))
(defun unordered-slot-test (x y)
  "Implements B5.3 and B5.4 shown above."
  (let ((xmi-uuid (xmi-sym "uuid"))
	(xmi-idref (xmi-sym "idref"))
	(xmi-href (xmi-sym "href")))
    (cond ((and (xqdm:element-p x) (xqdm:element-p y))
	   (let ((uuidx (xml-get-attr-value x xmi-uuid))
		 (uuidy (xml-get-attr-value y xmi-uuid))
		 (idrefx  (xml-get-attr-value x xmi-idref))
		 (idrefy  (xml-get-attr-value y xmi-idref))
		 (hrefx  (xml-get-attr-value x xmi-href))
		 (hrefy  (xml-get-attr-value y xmi-href)))
	     (cond ((and uuidx uuidy) (string< uuidx uuidy))
		   (uuidx t)
		   (uuidy nil)
		   ((and idrefx idrefy) (string< idrefx idrefy))
		   (idrefx t)
		   (idrefy nil)
		   ((and hrefx hrefy) (string< hrefx hrefy))
		   (t nil))))
	  ((xqdm:element-p x) t)
	  ((xqdm:element-p y) nil)
	  ((and (stringp x) (stringp y)) (string< x y))
	  (t nil))))

;;; The order of the XML elements of Properties is the order of the properties of the class in the metamodel. 
;;; This is determined by navigating the class hierarchy 'depth first' (e.g. highest superclass first).  
;;; In the case of multiple inheritance this is determined by alphabetic order of superclasses and 
;;; ignoring properties already present.
(defun xmi-reorder-node (node mut)
  "Reorder a single node. This is called by xmi-reorder-model and xmi-reorder-stereos."
  (with-slots (xmiid2obj-ht) (processing-results mut)			 
    (let ((xmi-id (xmi-sym "id")))
      (flet ((ename (elem) (string (xqdm:name elem)))
	     (sname (slot) (string (slot-definition-name slot))))
	(when (xqdm:element-p node)
	  (when-bind (obj (gethash (xml-get-attr-value node xmi-id) xmiid2obj-ht))
	    (when (typep obj 'mm-root-supertype) ; not T <============= POD INVESTIGATE! TC11
	      (let* ((slots (reverse (mapped-slots (class-of obj))))
		     (xml-properties 
		      (sort 
		       (remove-duplicates (mapcar #'(lambda (x) (ename x)) (xqdm:children node)))
		       #'(lambda (x y)
			   (> (length (member x slots :key #'sname :test #'string=))
			      (length (member y slots :key #'sname :test #'string=))))))
		     (class (class-of obj)))
		;;(VARS xml-properties obj)
		;;(when (= 2 (%debug-id obj)) (break "package id = 2"))
		(setf (xqdm:children node)
		      (sort (xqdm:children node)
			    #'(lambda (x y)
				(if (string= (ename x) (ename y)) 
				    (if-bind (slot (find (ename x) slots ; if-bind, then two ojects filling same slot.
							 :key #'slot-definition-name
							 :test #'string=))
					     (if (slot-definition-is-ordered-p slot) ;...keep order
						 (> (length (member x (xqdm:children node)))
						    (length (member y (xqdm:children node))))
						 (unordered-slot-test x y))
					     (format *error-output* "~%Cannot find property ~A while sorting ~A" 
						     (ename x) class))
				    ;; Else sort by property name
				    (> (length (member (ename x) xml-properties :test #'string=))
				       (length (member (ename y) xml-properties :test #'string=)))))))))))))))

;;; This is probably a waste of time.
(defun xmi-reset-xqdm-ordinality (doc)
  "Set the xqdm:ordinal value breadth-first."
  (let ((count 0))
    (breadth-first-search 
     (xqdm:root doc)
     #'fail
     #'xqdm:children
     :do #'(lambda (node) 
	     (when (typep node 'xqdm:ordinal-node)
	       (setf (xqdm:ordinality node) (incf count)))))))

(defun add-elem (name parent doc)
  "Add an element named NAME to PARENT."
  (let (elem)
    (setf (xqdm:children parent) 
	  (append (xqdm:children parent) 
		  (list (setq elem (xml-make-node doc parent name nil :type 'xqdm:elem-node)))))
    elem))


(defun add-attr (name value parent)
  "Add and attribute named NAME with value VALUE to PARENT, an xqdm:elem-node."
  (let (result)
    (push 
     (setf result
	   (make-instance 'xqdm:string-attr-node
			  :name name
			  :value value
			  :children (list value)
			  :parent parent
			  :document (xqdm:document parent)))
     (xqdm:attributes parent))
    result))


(defun set-content (elem value)
  "Set text/number content of PARENT to VALUE."
  (when value
    (unless (or (stringp value) (numberp value)) (error "set-content args"))
    (setf (xqdm:children elem) (list (if (stringp value) value (format nil "~A" value))))
    elem))


;;;=============================================================================================
;;; xmi:id naming for canonical
;;;=============================================================================================
#| From the 2012-01-01 document
  B6. IDENTIFICATION ...
     For xmi:ids the rules are as follows: these are based on the algorithm used for the normative UML
     metamodel.

• Where it exists and is unique, the xmi:id is the qualified name of the element (as defined in
UML). This is the names of all parent XML elements in sequence. However for XMI the
separator is ‘-’ (hyphen), since the UML separator, “::”, is not valid in XML identifiers.
Top level elements have a prefix of “_” (underscore). [WHAT DOES THAT MEAN?]

• In other cases the xmi:id is the xmi:id of the parent XML element (or “_” for top level elements),
followed by the separator ‘-‘, followed by the name of the property (XML element. If there is
more than one value for the property this is further followed by ‘-‘ followed by the sequence
number (from 1) within the parent element and the property. Note that named elements (which
satisfy the first rule) are still included in this count.

• Where the above rules result in characters not permitted for identifiers in XML documents (for
example space, ‘/’ or ‘:’ these must be replaced by ‘_’.
|#

#|
  From http://www.w3.org/TR/REC-xml/#id 
   Validity constraint: ID
   Values of type ID MUST match the Name production. A name MUST NOT appear more than once in an XML document 
   as a value of this type; i.e., ID values MUST uniquely identify the elements which bear them.
Names and Tokens
[4] NameStartChar ::=  ":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] 
                           | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] 
                           | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] 
                           | [#x10000-#xEFFFF]
[4a] NameChar ::= NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
[5] Name ::= NameStartChar (NameChar)*
[6] Names ::= Name (#x20 Name)*
[7] Nmtoken ::= (NameChar)+ 
[8] Nmtokens ::= Nmtoken (#x20 Nmtoken)*
|#
(defun xmi-compute-canonical-xmiid (mut)
  "Set the sort-name slot of objects that have a qualified name to a value based
   on the qualified name. Colon and many other characters can't be used in XML ids, 
   so follow guidance from Clause B.6    of the Canonical XMI Spec to change these to #\_."
  ;; Though Canonical XMI doesn't serialize names for datatypes, enumerations and primitives, 
  ;; I calculate them here anyway (OK?)
  (let ((mem-list (coerce (members mut) 'list))
	(name-ht (make-hash-table :test #'equal)))
    (loop for obj in mem-list do (setf (%sort-name obj) nil)) ; for diagnostics, at least.
    ;; Calculate qualified names. Where they aren't unique set them to nil. 
    (xmi-compute-canonical-xmiid-qualified mem-list mut)
    ;; Make a hash-table indexed by sort-name. Useful elsewhere.
    (loop for o in mem-list do (push o (gethash (%sort-name o) name-ht)))
    ;; Use alternative naming approach for those that don't have unique qualified names. 
    (loop for obj in (gethash nil name-ht) with xqdm2obj-ht = (xqdm2model-ht (processing-results mut))
       do (xmi-compute-canonical-xmiid-alternative obj name-ht xqdm2obj-ht))
    (loop for obj in mem-list 
       for sort-name = (%sort-name obj) do
	 (if sort-name ; POD to be safest, this should move to wherever the name is created.
	     (progn ; POD 2012-12-05 sloppy additional setting. 
	       (setf (%sort-name obj) (cl-ppcre:regex-replace-all "=" (%sort-name obj) "EQ"))
	       (setf (%sort-name obj) (cl-ppcre:regex-replace-all "<" (%sort-name obj) "LT"))
	       (setf (%sort-name obj) (cl-ppcre:regex-replace-all ">" (%sort-name obj) "GT"))
	       ;; Still dangerous!
	       (setf (%sort-name obj) (cl-ppcre:regex-replace-all "[^a-z,A-Z,0-9,\\.,\\-,\\_]" (%sort-name obj) "_")))
	     nil #|(warn "~A not given a sort-name." obj)|#)) ; 2012-10-03 I'm not sure that is a useful warning.
    ;; Diagnostic test
    #+debug
    (let ((dups (flatten (remove-if #'single-p (equiv-classes mem-list :key #'%sort-name)))))
      (loop for d in dups
	 do (format t "~%Dups (FAIL): obj ~A sort-name ~A" d (%sort-name d))))))

#+debug
(defun my-name-list (root)
  (let* ((*package* (lisp-package (mut *spare-session-vo*)))
	 (owner-fn (intern "%OWNER"))
	 (name-fn  (intern "%NAME"))
	 (ne-type  (intern "NamedElement")))
    (declare (special *package*))
    (when (typep root ne-type)
      (loop for next = root then (and (typep next ne-type) (funcall owner-fn next))
	 for name = (and next (typep next ne-type) (funcall name-fn next))
	 unless next return result
	 unless name do (return-from my-name-list nil)
	 collect name into result))))

(defun xmi-compute-canonical-xmiid-qualified (objs mut)
  "Set the sort-name to the qualified-name of the object in OBJS where possible.
   Returns nothing."
  (let* ((*package* (lisp-package (model-n+1 mut)))
	 (owner-fn (intern "%OWNER"))
	 (name-fn  (intern "%NAME"))
	 (ne-type  (intern "NamedElement")))
    (flet ((name-list (root)
	     (when (typep root ne-type)
	       (loop for next = root then (and (typep next ne-type) (funcall owner-fn next))
		  for name = (and next (typep next ne-type) (funcall name-fn next))
		  unless next return result
		  unless name do (return-from name-list nil)
		  collect name into result))))
      (let ((qobjs (loop for obj in objs
		         for name-list = (name-list obj)
			 when name-list
		         do (setf (%sort-name obj) (format nil "~{~A~^-~}" (reverse (name-list obj))))
		         and collect obj)))
    ;; Check for duplicates. nil those. 
    (when-bind (dups (flatten (remove-if #'single-p (equiv-classes qobjs :key #'%sort-name))))
      #+debug(format t "~% duplicates in qualified: ~A" dups)
      (loop for obj in dups do (setf (%sort-name obj) nil))))
      (values))))

;;; Calls itself recursively when a parent doesn't have a sort-name. 
(defun xmi-compute-canonical-xmiid-alternative (obj name-ht xqdm2model-ht)
  "Calculate names where there wasn't a unique qualified name. 
   B.6: 'Use the xmi:id of the parent XML element (or “_” for top level elements),
   followed by the separator ‘-‘, followed by the name of the property (XML element)
   Return the sort-name."
  (when (xqdm:element-p (%source-elem obj)) ; could be :mofi-make-instance (default value, not serialized anyway).
    (let* ((node (%source-elem obj))
	   (elem-name (string (xqdm:local-part (xqdm:name node))))
	   (base-name ; name without -<sequence number>
	    (format nil "~A-~A"
		    (if-bind (pelem (xqdm:parent node))
			     (if-bind (pobj (gethash pelem xqdm2model-ht))
				      (or (%sort-name pobj) 
					  (xmi-compute-canonical-xmiid-alternative pobj name-ht xqdm2model-ht))
				      "_") ; this one if parent is xmi:xmi (root)
			     "_")
		    elem-name))
	   ;; B.6: "If there is more than one value for the property this is further followed by ‘-‘ followed by 
	   ;; the sequence number (from 1) within the parent element and the property. Note that named elements 
	   ;; (which satisfy the first rule) are still included in this count."
	   (siblings (loop for cand in (xqdm:children (xqdm:parent node))
			when (string= elem-name (xqdm:local-part (xqdm:name cand)))
			collect cand))
	   (others (gethash base-name name-ht))) ; 2012-12-06
      (setf (%sort-name obj) ; 2012-12-06 The rule needs correction. (See notes from 2012-12-06.)   
	    (if (= 1 (+ (length others) (length siblings))) ; 2012-12-06 Others will add to the number
		base-name
		(format nil "~A-~A" base-name (1+ (position node siblings))))))))


;;; This doesn't get called within the code for xmi-compute-canonical-xmiid, rather
;;; it is called for cmof:tags and other stuff that don't have sort names (are mm-root-supertype)
;;; Calls itself recursively. No side-effects. Returns xmi:id string. 
(defun xmi-compute-canonical-xmiid-alternative/tags (mut doc id &key elem)
  "Calculate names where there wasn't a unique qualified name. 
   B.6: 'Use the xmi:id of the parent XML element (or “_” for top level elements),
   followed by the separator ‘-‘, followed by the name of the property (XML element)
   Return the sort-name."
  (let ((xmi-id (xmi-sym "id"))
	(xmi-xmi (xmi-sym "XMI")))
    (flet ((find-obj (id)
	     (breadth-first-search doc 
				   #'(lambda (n)
				       (and (xqdm:element-p n)
					    (mvb (my-id ignore) (xml-get-attr-value n xmi-id)
					      (declare (ignore ignore))
					      (eql my-id id))))
				   #'xqdm:children)))
      (if-bind (node (or elem (and id (find-obj id))))
	       (let* ((elem-name (string (xqdm:local-part (xqdm:name node))))
		      (base-name ; name without -<sequence number>
		       (format nil "~A-~A"
			       (if-bind (pelem (xqdm:parent node))
					(if (xml-typep pelem xmi-xmi)
					    "_"
					    (xmi-compute-canonical-xmiid-alternative/tags mut doc nil :elem pelem))
					"_") 
			       elem-name))
		      ;; B.6: "If there is more than one value for the property this is further followed by ‘-‘ followed by 
		      ;; the sequence number (from 1) within the parent element and the property. Note that named elements 
		      ;; (which satisfy the first rule) are still included in this count."
		      (siblings (loop for cand in (xqdm:children (xqdm:parent node))
				   when (string= elem-name (xqdm:local-part (xqdm:name cand)))
				   collect cand)))
		 (if (= (length siblings) 1)
		     base-name
		     (format nil "~A-~A" base-name (1+ (position node siblings)))))
	       (warn "Couldn't find elem in compute-canonical-xmiid-alternative/tag for ~A" id)))))

