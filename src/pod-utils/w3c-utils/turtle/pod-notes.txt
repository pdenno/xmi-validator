- Test it. 
    Test 1: See the turtle-parser.lisp file (and below)
    Test 2: Check it against odmrdf2xml
    Test 3: Write odmrdf2ttl and test against qif2.ttl  (The BIG test). 

(turtle2rdf 
"
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix dc: <http://purl.org/dc/elements/1.1/> .
@prefix ex: <http://example.org/stuff/1.0/> .

<http://www.w3.org/TR/rdf-syntax-grammar>
  dc:title \"RDF/XML Syntax Specification (Revised)\" ;
  ex:editor [
    ex:fullname \"Dave Beckett\";
    ex:homePage <http://purl.org/net/dajobe/>
  ] .
")

;;;===============================
;;; "2014-12-01 10:23:51"
;;;===============================

I'm continuing to upgrade my turtle parser for use with 2013 ODM RDF objects. 
What I suggested before the break is:

- Test it. 
    Test 1: See the turtle-parser.lisp file (and below)
    Test 2: Check it against odmrdf2xml
    Test 3: Write odmrdf2ttl and test against qif2.ttl  (The BIG test). 

I'm not sure why I care about Test 2. It uses Anderson XML, so that's another reason
not to care. I'm doing Test 1 and Test 3. The risk with Test 1 is that I got the
order of statements messed (push-last vs push issue from older code). 

===> Ideas for odmrdf2ttl: 

I think there is a fundamental lacuna in using only ODM rdf objects:

[1] 	turtleDoc 	::= 	statement*
[2] 	statement 	::= 	directive | triples '.'
[3] 	directive 	::= 	prefixID | base | sparqlPrefix | sparqlBase

I am going to create objects for turtleDoc


I don't think I can make it verbatim without tracking line-numbers or something similar.
It is supposed to be a graph, however. Doesn't that mean that this shouldn't be necessary?

 - Walk through graph.triples collecting every one on the same subject

The challenge is getting "abbreviated form" instead of simple triples:

Abbreviated:

@prefix foaf: <http://xmlns.com/foaf/0.1/> .

[ foaf:name "Alice" ] foaf:knows [
    foaf:name "Bob" ;
    foaf:knows [
        foaf:name "Eve" ] ;
    foaf:mbox <bob@example.com> ] .

Same thing as simple triples:

_:a <http://xmlns.com/foaf/0.1/name> "Alice" .
_:a <http://xmlns.com/foaf/0.1/knows> _:b .
_:b <http://xmlns.com/foaf/0.1/name> "Bob" .
_:b <http://xmlns.com/foaf/0.1/knows> _:c .
_:c <http://xmlns.com/foaf/0.1/name> "Eve" .
_:b <http://xmlns.com/foaf/0.1/mbox> <bob@example.com> .

When you encounter a blank node used as a subject, find where it used as an object and
connect into that. 


;;;=========================
;;; "2014-12-04 13:22:00"
;;;=========================

4      <odm:BlankNode, id=5> #<IRI "http://example.org/stuff/1.0/fullname", id=6> "Dave Beckett"
5      <odm:BlankNode, id=5> #<IRI "http://example.org/stuff/1.0/homePage", id=8> #<IRI "http://purl.org/net/dajobe/", id=9>
6      #<IRI "http://www.w3.org/TR/rdf-syntax-grammar", id=1> #<IRI "http://example.org/stuff/1.0/editor", id=4> <odm:BlankNode, id=5>
 
I'm giving up on trying to reorder these. It will be easier to just scan when printing. 

The ODM spec says "RDF provides ...statement.. without formal semantics." -- I have statement slots 
in the ODM:Triple object, I just don't use it. 

;;;========================
;;; "2014-12-11 17:01:49"
;;;========================

Ugh... getting back to this! 


;;;========================
;;; "2014-12-12 11:57:22"
;;;========================

Calling with this

        TRIP = #<IRI "http://www.w3.org/TR/rdf-syntax-grammar", id=144> #<IRI "http://example.org/stuff/1.0/editor", id=147> <odm:BlankNode, id=148>
        PRED-OBJ-ONLY = T

I thought this was bad syntax (found in TBC-generated file):

dc:description
  rdfs:label "description"^^xsd:string ;
 .

But it is OK:
predicateObjectList	::=	verb objectList (';' (verb objectList)?)*

As it shows, they allow the ';' even if there isn't going to be another verb. Later comes the period
to end the Statement production. 

Question: Now should I generate ugly code like that? (They don't have common lisp ~^) I think not.


---> RDF Literals aren't nice looking (there just strings). 

<odm:Triple, id=239129> is an ODM:|Triple|
RDFobject           "\"description\"^^<http://www.w3.org/2001/XMLSchema#string>"


During parsing, I should create and rdf-literal object with slots -value -lang -ns. 
DONE. 

---> Next thing to do is handle object lists:
No applicable methods for #<COMMON-LISP:STANDARD-GENERIC-FUNCTION ODM2TTL 24D2A152> with args 
   ((#<IRI "http://qifstandards.org/xsd/qif2#ATTET_CONTAINMENT", id=386330>
   	   #<IRI "http://qifstandards.org/xsd/qif2#ATTET_HALT_PRODUCTION", id=386331>
           #<IRI "http://qifstandards.org/xsd/qif2#ATTET_INSPECT_100PC", id=386332>
           #<IRI "http://qifstandards.org/xsd/qif2#ATTET_NEW_MATERIAL_BATCH", id=386333>
           #<IRI "http://qifstandards.org/xsd/qif2#ATTET_NEW_TOOLING", id=386334>
           #<IRI "http://qifstandards.org/xsd/qif2#ATTET_OTHER", id=386335>
           #<IRI "http://qifstandards.org/xsd/qif2#ATTET_REBOOT", id=386336>
           #<IRI "http://qifstandards.org/xsd/qif2#ATTET_RECALIBRATE", id=386337>)
                                                   NIL)

TBC isn't placing commas between them because there are collections, not separate object lists
(which would each generate a triple). How did this occur? Was there a odm:RDFCollection type
I'm not taking advantage of?

;;;========================
;;; "2014-12-15 10:26:57"
;;;========================

Looking at the Turtle spec, it appears that List is the only collection implemented. 
It says:

"RDF provides a Collection [RDF11-MT] structure for lists of RDF nodes. The Turtle syntax for 
Collections is a possibly empty list of RDF terms enclosed by (). This collection represents an 
rdf:first/rdf:rest list structure with the sequence of objects of the rdf:first statements 
being the order of the terms enclosed by ()."

So I think I'll use odm:|RDFList|


OK. It executes really SLOW. I'm addressing that with memoizing more-on-subject. 

It is having a problem with this, because of the blank node in the object list: 

qif2:B2TypeDatatype
  rdf:type rdfs:Datatype ;
  dc:description "The B2Type is an array of two Boolean values."^^xsd:string ;
  rdfs:label "B2Type datatype"^^xsd:string ;
  rdfs:subClassOf qif2:ListBoolTypeDatatype ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype qif2:ListBoolTypeDatatype ;
      owl:withRestrictions (
          [
            xsd:length "2"^^xsd:anySimpleType ;
          ]
        ) ;
    ] ;
.


--> Here is another problem. It can't print numbers as object!
qif2:Int15TypeDatatype
  rdf:type rdfs:Datatype ;
  dc:description "The Int15Type is an integer type, having values from the range [1..5]."^^xsd:string ;
  rdfs:label "Int15Type datatype"^^xsd:string ;
  rdfs:subClassOf xsd:integer ;
  owl:equivalentClass [
      rdf:type rdfs:Datatype ;
      owl:onDatatype xsd:integer ;
      owl:withRestrictions (
          [
            xsd:maxInclusive 5 ;
          ]
          [
            xsd:minInclusive 1 ;
          ]
        ) ;
    ] ;
.





;;;----------------Execution speed -----------

(reading QIF, 70k lines of Turtle)
User time    =       11.713
System time  =        0.478
Elapsed time =       12.214
Allocation   = 1619757268 bytes
0 Page faults
Calls to %EVAL    53336
#<TurtleDoc 48403 statements>

(writing QIF)  YES, 43 MINUTES!
Timing the evaluation of (DOGFOOD2 THAT)

User time    =  0:43:28.766
System time  =        8.818
Elapsed time =  0:43:41.382
Allocation   = 487666196528 bytes
0 Page faults
Calls to %EVAL    109172775


;;;=======================
;;; "2015-03-10 12:21:42"
;;;=======================

A review of status: 

I'm once again getting back to this. This week I'd like to get a file of turtle for the ODM mapping
of the modelica model to Elisa Kendall. Yesterday I thought the method to do this would be to 
QVT map the ODM to RDF and use the turtle code. There are problems with that! OWL is RDF, but
the OWL metamodel is not so easily rendered as RDF. I do, however, have turtle/odmrdf2ttl.lisp
which I worked 2014-12-15. This was the thing that was incredibly slow on QIF because of the size
and searching that it does. (Note that the above suggests that at least I can read .ttl.)

I don't know what I had in mind for the relationship between the above work on turtle/odmrdf2ttl.lisp and 
uml2owl/owl2turtle.lisp. The latter almost looks like a throwaway, with its hard-coding of modelica
and modelica-e prefixes. It is a month older and there is the comment above  "2014-11-23 01:22:08" :
"I suppose it should be elevated to a uml-utils package. But for now, good enough. "

DECISION: Merge uml2owl/owl2turtle.lisp into the pod-utils/w3c-utils/turtle code. 
DECISION: There is no need to QVT map to RDF to get .ttl. odmrdf2ttl (a slight misnomer) should do the whole thing. 

This is what the original owl code does:
GATOR> (odm-test mofi:*population*)

@prefix modelica: <http://modelmeth.nist.gov/modelica/ModelicaMetamodel#> .
@prefix modelica-e: <http://modelmeth.nist.gov/modelica/Expression#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

<http://modelmeth.nist.gov/modelica/Expression>
  rdf:type owl:Ontology ;
  owl:versionInfo "Created by Modelegator mapping"^^xsd:string ;
.
<http://modelmeth.nist.gov/modelica/ModelicaMetamodel>
  rdf:type owl:Ontology ;
  owl:versionInfo "Created by Modelegator mapping"^^xsd:string ;
.
<http://modelmeth.nist.gov/modelica/Data>
  rdf:type owl:Ontology ;
  owl:versionInfo "Created by Modelegator mapping"^^xsd:string ;
.
modelica:Constant
  rdf:type owl:Class ;
  rdfs:subClassOf modelica:Component ;
.
modelica:ArrayType
  rdf:type owl:Class ;
  rdfs:subClassOf modelica:Type ;
.

etc. 

After basic merge, prefixes don't seem to be working. FIXED. 

To Do:
 - Assocaiate Classes with Ontologies (packages)
 - DONE: Serialize classes in alphabetical order
 - Map comments 

;;;=========================
;;; "2015-09-19 13:33:29"
;;;=========================

I'm continuing development of turtle serialization of the entire mofi:*population* generated by 
QVT mapping of the modelica metamodel to OWL. The idea is to get this to Evan and Elisa
for validation. What is shown above (2015-03-10) is really just about everything that is 
currently serialized. The idea for today (forever? since I'm moving to Clojure) is to get all 
the triples out. 

My notes indicated that odmrdf2owl is slow on the (very large) QIF model. (And I read that
in with the turtle parser???) What I am doing today is the Modelical metamodel, which is
ODM generated by a QVT mapping. Maybe, it being slower, I can get decent output and put
this thing to rest. 

(defmethod odm2ttl ((popu mofi:population) stream &key)
 - Currently, this is just printing the ontologies and classes. 

--> set-written is never executed. So what is doing the writing?
Answer: odm2ttl, but the stuff for brought in (where it says:
;;; OWL stuff (originally from modelegator/uml2owl/owl2turtle.lisp called odm2turtle
doesn't use set-written. Now it does, FWIW.

This will be useful!
/home/pdenno/rt/projects/mm/source/ontology/modelica-tbc-generated

1) MaxCardinalityRestriction. I'm looking for somethiing like this:

:Algorithm
  rdf:type owl:Class ;
  rdfs:subClassOf [
      rdf:type owl:Restriction ;
      owl:maxCardinality "1"^^xsd:int ;
      owl:onProperty :hasIsInitial ;
    ] ;


<odm:MaxCardinalityRestriction, id=20902> is an ODM:|MaxCardinalityRestriction|
cardinality            1
qualifiedByClass       <odm:OWLClass, id=21976>
OWLonProperty          <odm:Property, id=20899>
iri                    <odm:BlankNode, id=20901>

<odm:Property, id=20899> is an ODM:|Property|
iri                        #<IRI "http://modelmeth.nist.gov/modelica/ModelicaMetamodel/visibility", id=20898>

<odm:BlankNode, id=20901> is an ODM:|BlankNode|
nodeID              "anonNode5"



